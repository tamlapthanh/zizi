<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matching Game</title>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/konva@9.3.14/konva.min.js"></script>
  

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    .modal-content {
      text-align: center;
    }
    .modal-header, .modal-body, .modal-footer {
      border: none;
    }
    .modal-body select {
      margin: 10px 0;
    }
    .modal-footer button {
      margin: 0 5px;
    }

    #settingsButton {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
    }

  </style>
</head>
<body>
  
  <div id="container">
   
  </div>
  <button id="settingsButton" class="btn btn-primary btn-sm" ><i class="bi bi-gear"></i></button>
  
  <!-- Modal -->
  <div class="modal fade" id="vocabModal" tabindex="-1" role="dialog" aria-labelledby="vocabModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="vocabModalLabel">Chọn bộ từ vựng</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <select id="vocabSelect" class="form-control">
            <option value="animals">Tên con vật</option>
            <option value="householdItems">Vật dụng trong nhà</option>
          </select>
         <select id="vocabNum" class="form-control">
            <option value="5">5 câu</option>
            <option value="10">10 câu</option>
            <option value="15">15 câu</option>
            <option value="20">20 câu</option>
            <option value="100">Thôi chơi tất</option>
          </select>
          <select id="voiceSelect" class="form-control">
          </select>

          <select id="rateSelect" class="form-control">
            <option value="1">Đọc bình thường</option>
            <option value="0.85">Đọc chậm 0.85</option>
            <option value="0.75">Đọc chậm 0.75</option>
          </select>

        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-primary btn-sm" id="startButton">Chơi thôi, bệnh gì cữ</button>
          <button type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Bỏ đi 8</button>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.3/dist/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script>
    

          let stage, layer;
          let words = [];
          let meanings = [];
          let correctMatches = {};
          let selectedWord = null;
          let texts = [];

          let voices = [];
          let selectedVoiceIndex = null;


          const vocab = {
            animals: [
            { "word": "Dog", "meaning": "Chó", "lang": "en" },
            { "word": "Cat", "meaning": "Mèo", "lang": "en" },
            { "word": "Bird", "meaning": "Chim", "lang": "en" },
            { "word": "Fish", "meaning": "Cá", "lang": "en" },
            { "word": "Elephant", "meaning": "Voi", "lang": "en" },
            { "word": "Horse", "meaning": "Ngựa", "lang": "en" },
            { "word": "Rabbit", "meaning": "Thỏ", "lang": "en" },
            { "word": "Lion", "meaning": "Sư tử", "lang": "en" },
            { "word": "Tiger", "meaning": "Hổ", "lang": "en" },
            { "word": "Bear", "meaning": "Gấu", "lang": "en" },
            { "word": "Giraffe", "meaning": "Hươu cao cổ", "lang": "en" },
            { "word": "Kangaroo", "meaning": "Kangaroo", "lang": "en" },
            { "word": "Zebra", "meaning": "Ngựa vằn", "lang": "en" },
            { "word": "Penguin", "meaning": "Chim cánh cụt", "lang": "en" },
            { "word": "Dolphin", "meaning": "Cá heo", "lang": "en" },
            { "word": "Whale", "meaning": "Cá voi", "lang": "en" },
            { "word": "Shark", "meaning": "Cá mập", "lang": "en" },
            { "word": "Eagle", "meaning": "Đại bàng", "lang": "en" },
            { "word": "Owl", "meaning": "Cú", "lang": "en" },
            { "word": "Snake", "meaning": "Rắn", "lang": "en" },
            { "word": "Frog", "meaning": "Ếch", "lang": "en" },
            { "word": "Turtle", "meaning": "Rùa", "lang": "en" },
            { "word": "Panda", "meaning": "Gấu trúc", "lang": "en" },
            { "word": "Wolf", "meaning": "Sói", "lang": "en" },
            { "word": "Fox", "meaning": "Cáo", "lang": "en" },
            { "word": "Hippopotamus", "meaning": "Hà mã", "lang": "en" },
            { "word": "Rhinoceros", "meaning": "Tê giác", "lang": "en" },
            { "word": "Cheetah", "meaning": "Báo gấm", "lang": "en" },
            { "word": "Leopard", "meaning": "Báo", "lang": "en" },
            { "word": "Hyena", "meaning": "Linh cẩu", "lang": "en" },
            { "word": "Koala", "meaning": "Koala", "lang": "en" },
            { "word": "Sloth", "meaning": "Lười", "lang": "en" },
            { "word": "Armadillo", "meaning": "Lợn biển", "lang": "en" },
            { "word": "Bat", "meaning": "Dơi", "lang": "en" },
            { "word": "Otter", "meaning": "Rái cá", "lang": "en" },
            { "word": "Porcupine", "meaning": "Nhím", "lang": "en" },
            { "word": "Meerkat", "meaning": "Chồn mangut", "lang": "en" },
            { "word": "Kangaroo Rat", "meaning": "Chuột kangaroo", "lang": "en" },
            { "word": "Bison", "meaning": "Bò rừng", "lang": "en" },
            { "word": "Gorilla", "meaning": "Gorilla", "lang": "en" },
            { "word": "Baboon", "meaning": "Khỉ đầu chó", "lang": "en" },
            { "word": "Chimpanzee", "meaning": "Tinh tinh", "lang": "en" },
            { "word": "Puma", "meaning": "Puma", "lang": "en" },
            { "word": "Cougar", "meaning": "Cougar", "lang": "en" },
            { "word": "Jaguar", "meaning": "Jaguar", "lang": "en" },
            { "word": "Okapi", "meaning": "Okapi", "lang": "en" },
            { "word": "Tapir", "meaning": "Tapir", "lang": "en" },
            { "word": "Warthog", "meaning": "Lợn rừng", "lang": "en" },
            { "word": "Pangolin", "meaning": "Tê tê", "lang": "en" },
            { "word": "Anteater", "meaning": "Thú ăn kiến", "lang": "en" },
            { "word": "Aardvark", "meaning": "Aardvark", "lang": "en" },
            { "word": "Squirrel", "meaning": "Sóc", "lang": "en" },
            { "word": "Hedgehog", "meaning": "Nhím", "lang": "en" },
            { "word": "Mole", "meaning": "Chuột chũi", "lang": "en" },
            { "word": "Weasel", "meaning": "Chồn", "lang": "en" },
            { "word": "Skunk", "meaning": "Chồn hôi", "lang": "en" },
            { "word": "Opossum", "meaning": "Opossum", "lang": "en" },
            { "word": "Wombat", "meaning": "Wombat", "lang": "en" },
            { "word": "Tasmanian Devil", "meaning": "Quỷ Tasmania", "lang": "en" },
            { "word": "Dingo", "meaning": "Chó rừng Úc", "lang": "en" }
            ],
            householdItems: [
              { word: 'Table', meaning: 'Bàn', lang: 'en' },
              { word: 'Chair', meaning: 'Ghế', lang: 'en' },
              { word: 'Lamp', meaning: 'Đèn', lang: 'en' },
              { word: 'Sofa', meaning: 'Sofa', lang: 'en' },
              { word: 'Bed', meaning: 'Giường', lang: 'en' },
              { word: 'Refrigerator', meaning: 'Tủ lạnh', lang: 'en' },
              { word: 'Oven', meaning: 'Lò nướng', lang: 'en' },
              { word: 'Microwave', meaning: 'Lò vi sóng', lang: 'en' },
              { word: 'Washing Machine', meaning: 'Máy giặt', lang: 'en' },
              { word: 'Toaster', meaning: 'Máy nướng bánh', lang: 'en' },
              { word: 'Cabinet', meaning: 'Tủ đựng đồ', lang: 'en' },
              { word: 'Shelf', meaning: 'Kệ', lang: 'en' },
              { word: 'Curtain', meaning: 'Rèm cửa', lang: 'en' },
              { word: 'Mirror', meaning: 'Gương', lang: 'en' },
              { word: 'Clock', meaning: 'Đồng hồ', lang: 'en' },
              { word: 'Painting', meaning: 'Tranh', lang: 'en' },
              { word: 'Carpet', meaning: 'Thảm', lang: 'en' },
              { word: 'Pillow', meaning: 'Gối', lang: 'en' },
              { word: 'Blanket', meaning: 'Chăn', lang: 'en' },
              { word: 'Drawer', meaning: 'Ngăn kéo', lang: 'en' }
            ]
          };

    
          const getFontSize = () => {
            const width = window.innerWidth;
            return width < 800 ? 32 : 24; // Responsive font size
        };

          const getRandomElements = (arr, count) => {
            if (count == 100) {
              count = arr.length - 1  ;
            }
            const shuffled = arr.slice(0);
            let i = shuffled.length, temp, index;
            while (i--) {
              index = Math.floor(Math.random() * (i + 1));
              temp = shuffled[i];
              shuffled[i] = shuffled[index];
              shuffled[index] = temp;
            }
            return shuffled.slice(0, count);
          };

          const getRandomWordsAndMeanings = (vocabCategory, selectedNum) => {
            const vocabList = vocab[vocabCategory];
            const pairs = getRandomElements(vocabList, selectedNum); // Choose 5 pairs
            words = pairs.map(pair => pair.word);
            meanings = pairs.map(pair => pair.meaning);
            correctMatches = {};
            pairs.forEach(pair => {
              correctMatches[pair.word] = pair.meaning;
              correctMatches[pair.meaning] = pair.word; // Add reverse mapping
            });
          };

          const isOverlapping = (pos, size) => {
            const padding = 20;
            return texts.some(txt => {
              const txtPos = txt.getClientRect();
              return !(pos.x + size.width < txtPos.x ||
                      pos.x > txtPos.x + txtPos.width ||
                      pos.y + size.height < txtPos.y ||
                      pos.y > txtPos.y + txtPos.height);
            });
          };

          const getRandomPosition = (size) => {
            let pos;
            do {
              pos = {
                x: Math.random() * (stage.width() - size.width),
                y: Math.random() * (stage.height() - size.height),
              };
            } while (isOverlapping(pos, size));
            return pos;
          };

          const createText = (text, x, y, color) => {
            const fontSize = getFontSize();
            const txt = new Konva.Text({
                x: x,
                y: y,
                text: text,
                fontSize: fontSize * (stage.width() / 800), // Responsive font size
                fontFamily: 'Calibri',
                fill: color,
                padding: 10,
                align: 'center',
                verticalAlign: 'middle',
                draggable: true,
                isSelected: false
            });
        
            txt.on('mouseover', () => {
                document.body.style.cursor = 'pointer';
                txt.fill('green'); // Đổi màu khi hover
                layer.draw();
            });
        
            txt.on('mouseout', () => {
                document.body.style.cursor = 'default';
                if (!txt.isSelected) {
                    txt.fill(color); // Trả lại màu ban đầu nếu không được chọn
                }
                layer.draw();
            });
        
            txt.on('dragstart touchstart', () => {
                txt.moveToTop();
                txt.startX = txt.x();
                txt.startY = txt.y();
            });
        
            txt.on('dragmove touchmove', () => {
                texts.forEach(otherTxt => {
                    if (txt !== otherTxt && checkCollision(txt, otherTxt)) {
                        otherTxt.fill('orange'); // Đổi màu từ khác khi gần
                    } else if (!otherTxt.isSelected) {
                        otherTxt.fill(otherTxt.originalFill); // Trả lại màu ban đầu nếu không còn gần
                    }
                });
                layer.draw();
            });
        
            txt.on('dragend touchend', () => {
                let droppedOnText = null;
                texts.forEach(otherTxt => {
                    if (txt !== otherTxt && checkCollision(txt, otherTxt)) {
                        droppedOnText = otherTxt;
                    }
                });
        
                if (droppedOnText) {
                    handleDrop(txt, droppedOnText);
                } else {
                   playTextSound(txt);
                    txt.position({ x: txt.startX, y: txt.startY }); // Trả lại vị trí cũ nếu không có từ nào gần
                }
                layer.draw();
            });
        
            txt.on('click tap', () => {
                handleTextSelection(txt);
            });
        
            txt.originalFill = color; // Lưu màu gốc
            return txt;
        };

        const handleTextSelection = (txt) => {
          
          if (selectedWord === null) {
              selectedWord = txt;
              txt.isSelected = true;
              txt.fill('yellow'); // Đổi màu từ được chọn
          } else if (selectedWord !== txt) {
              if (correctMatches[selectedWord.text()] === txt.text() || correctMatches[txt.text()] === selectedWord.text()) {
                  handleDrop(selectedWord, txt);
              } else {
                  selectedWord.fill(selectedWord.originalFill); // Trả lại màu ban đầu nếu không khớp
                  selectedWord.isSelected = false;
                  txt.fill(txt.originalFill); // Trả lại màu ban đầu nếu không khớp
                  playTextSound(txt);
              }
              selectedWord = null;
          }
          layer.draw();
      };

      
        const checkCollision = (txt1, txt2) => {
          const rect1 = txt1.getClientRect();
          const rect2 = txt2.getClientRect();
          return !(rect1.x > rect2.x + rect2.width ||
                   rect1.x + rect1.width < rect2.x ||
                   rect1.y > rect2.y + rect2.height ||
                   rect1.y + rect1.height < rect2.y);
      };
      
      const handleDrop = (txt1, txt2) => {
          const word1 = txt1.text();
          const word2 = txt2.text();
      
          playTextSound(word1);
          playTextSound(word2);

          if (correctMatches[word1] === word2 || correctMatches[word2] === word1) {
              txt1.destroy(); // Xóa từ đầu tiên
              txt2.destroy(); // Xóa từ thứ hai
              layer.draw();
              if (texts.every(txt => !txt.getStage())) {
                  createFireworks(); // Tất cả các từ đã được ghép chính xác
              }
          } else {
              // Trả về vị trí ban đầu
              txt1.position({ x: txt1.startX, y: txt1.startY });
              //txt2.position({ x: txt2.startX, y: txt2.startY });
              layer.draw();
          }
      };

          // Hàm khởi tạo các từ
    const createObjects = () => {
      var vocabCategory = document.getElementById('vocabSelect').value;
      var selectedNum = document.getElementById('vocabNum').value;
  
      layer.destroyChildren();
      texts = [];
      getRandomWordsAndMeanings(vocabCategory, selectedNum);
  
      words.forEach(word => {
          const fontSize = getFontSize();
          const size = { width: 100 * (stage.width() / 800), height: fontSize };
          const pos = getRandomPosition(size);
          const text = createText(word, pos.x, pos.y, 'black');
          texts.push(text);
          layer.add(text);
      });
  
      meanings.forEach(meaning => {
          const fontSize = getFontSize();
          const size = { width: 100 * (stage.width() / 800), height: fontSize };
          const pos = getRandomPosition(size);
          const text = createText(meaning, pos.x, pos.y, 'blue');
          texts.push(text);
          layer.add(text);
      });
  
      layer.draw();
  };

          const createFireworks = () => {
            const fireworksLayer = new Konva.Layer();
            stage.add(fireworksLayer);
          
            const createExplosion = (x, y) => {
              const particles = [];
              const numParticles = 50;
          
              for (let i = 0; i < numParticles; i++) {
                const angle = (Math.PI * 2 * i) / numParticles;
                const speed = Math.random() * 2 + 2;
                const particle = new Konva.Circle({
                  x: x,
                  y: y,
                  radius: Math.random() * 3 + 2,
                  fill: `hsl(${Math.random() * 360}, 100%, 50%)`,
                  opacity: 1,
                });
                fireworksLayer.add(particle);
                particles.push({ particle, angle, speed });
              }
          
              const anim = new Konva.Animation((frame) => {
                particles.forEach(({ particle, angle, speed }) => {
                  const velocityX = Math.cos(angle) * speed;
                  const velocityY = Math.sin(angle) * speed;
                  particle.x(particle.x() + velocityX);
                  particle.y(particle.y() + velocityY);
                  particle.opacity(particle.opacity() - 0.02);
                  if (particle.opacity() <= 0) {
                    particle.destroy();
                  }
                });
                fireworksLayer.batchDraw();
              }, fireworksLayer);
          
              anim.start();
          
              setTimeout(() => {
                anim.stop();
                particles.forEach(({ particle }) => particle.destroy());
                fireworksLayer.draw();
              }, 1000);
            };
          
            const numFireworks = 10;
            for (let i = 0; i < numFireworks; i++) {
              setTimeout(() => {
                const x = Math.random() * stage.width();
                const y = Math.random() * stage.height();
                createExplosion(x, y);
              }, i * 200);
            }
          
            // Reset the game after the fireworks effect
            setTimeout(() => {
              const selectedCategory = document.getElementById('vocabSelect').value;
              const selectedNum = document.getElementById('vocabNum').value;
          
              createObjects(); // Reset with the same category
            }, 3000); // Wait for fireworks to finish before resetting
          };

          function isEnglishWord(word) {
            return /^[a-zA-Z]+$/.test(word);
        }
        

          const playTextSound = (text) => {
           
            let utterance = new SpeechSynthesisUtterance(text);
            // const isVietnamese = vocab.animals.some(pair => pair.meaning === text) || vocab.householdItems.some(pair => pair.meaning === text);
            const isEnglish = isEnglishWord(text);
            
            if (isEnglish) {
                utterance.lang =  'en-US';
                if (voices && selectedVoiceIndex) {
                  const selectedVoice = voices[selectedVoiceIndex];
                  if (selectedVoice) {
                    utterance.voice = selectedVoice;
                  }
                }
            }
            else {
              utterance.lang = 'vi-VN' ;
            }

            
            speechSynthesis.speak(utterance);
          };

          const handleTextClick = (text) => {
            if (text.isSelected) return;

            if (selectedWord) {
              const word = selectedWord.text();
              const meaning = text.text();
              if (correctMatches[word] === meaning || correctMatches[meaning] === word) {
                const matchedWord = selectedWord;
                const matchedMeaning = text;

                const tween1 = new Konva.Tween({
                  node: matchedWord,
                  duration: 0.5,
                  scaleX: 0,
                  scaleY: 0,
                  opacity: 0,
                  onFinish: () => {
                    matchedWord.destroy();
                    texts.splice(texts.indexOf(matchedWord), 1);
                  },
                });

                const tween2 = new Konva.Tween({
                  node: matchedMeaning,
                  duration: 0.5,
                  scaleX: 0,
                  scaleY: 0,
                  opacity: 0,
                  onFinish: () => {
                    matchedMeaning.destroy();
                    texts.splice(texts.indexOf(matchedMeaning), 1);
                    if (texts.length === 0) {
                      createFireworks(); // Create fireworks effect when the game is completed
                    }
                  },
                });

                tween1.play();
                tween2.play();
                selectedWord = null;
                layer.draw();
              } else {
                // Remove color of the selected words if they do not match
                selectedWord.fill('black');
                text.fill('black');
                selectedWord.isSelected = false;
                text.isSelected = false;
                selectedWord = null;
                layer.draw();
              }
            } else {
              // Reset the previously selected word if needed
              if (selectedWord) {
                selectedWord.fill('black');
              }

              selectedWord = text;
              selectedWord.fill('red');
              selectedWord.isSelected = true;
            }
            layer.draw();
          };

          const init = () => {
            stage = new Konva.Stage({
              container: 'container',
              width: window.innerWidth,
              height: window.innerHeight,
            });

            layer = new Konva.Layer();
            stage.add(layer);

            window.addEventListener('resize', () => {
              stage.width(window.innerWidth);
              stage.height(window.innerHeight);
              if ($('.modal').hasClass('show') === false) {
                const selectedCategory = document.getElementById('vocabSelect').value;
                const selectedNum = document.getElementById('vocabNum').value;
                createObjects(); // Initialize with selected category
              }
            });

            $('#startButton').on('click', () => {
              const selectedCategory = document.getElementById('vocabSelect').value;
              const selectedNum = document.getElementById('vocabNum').value;
              createObjects();
              $('#vocabModal').modal('hide'); // Close modal
            });


            // Handle voice selection change
            voiceSelect.addEventListener('change', () => {
                selectedVoiceIndex = voiceSelect.value;
            });

            settingsButton.addEventListener('click', () => {
              
              $('#vocabModal').modal('show'); 
            });
          };

          function loadVoices() {
            return new Promise((resolve, reject) => {
              let voices = speechSynthesis.getVoices();
              if (voices.length) {
                resolve(voices);
                return;
              }
              
              speechSynthesis.onvoiceschanged = () => {
                voices = speechSynthesis.getVoices();
                if (voices.length) {
                  resolve(voices);
                } else {
                  reject('No voices available.');
                }
              };
            });
          }


  $(function() {
    init();
    createObjects();
    //createFireworks();

    loadVoices().then(voices => {
        console.log(voices);
          voices.forEach((voice, index) => {
            if (voice.name.includes('English')) {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = "Giọng " + voice.name;
                voiceSelect.appendChild(option);

                // Set default to US English
                if (voice.name.includes('US English') || voice.name.includes('Female')  || voice.name.includes('States') ) {
                  voiceSelect.value = index;
                  selectedVoiceIndex = index;
                }

            }
          });
  })
  .catch(error => {
    console.error(error);
  });

  }); // end of $(function() {
    
  </script>
</body>
</html>
